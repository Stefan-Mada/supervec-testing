Source file:

void function(unsigned char vin[], unsigned char vout[])
{
	constexpr int height = 800;
	constexpr int width = 600;

	int currentIndex, avgColor, redColor, greenColor, blueColor;
	
	for(int i = 0; i < height; ++i)
	{
		for(int j = 0; j < width; ++j)
		{
			currentIndex = (i * width + j) * 3;

			redColor = vin[currentIndex];
			greenColor = vin[currentIndex + 1];
			blueColor = vin[currentIndex + 2];

			avgColor = (redColor + greenColor + blueColor) / 3;

			for(int i = 0; i < 3; ++i)
				vout[currentIndex + i] = avgColor;
		}
	}
}

Compiled using:
clang++ -I -march=native -mavx2 -O3 -Werror -S -emit-llvm function.cpp -o function.ll

Called supervec using:
$HOME/llvm/build/bin/opt -enable-new-pm=0 -load $HOME/minotaur/build/minotaur.so -so -S function.ll


Sketches output:
$HOME/llvm/build/bin/opt  -enable-new-pm=0 -load $HOME/minotaur/build/minotaur.so -so -S function.ll
---------Sketches------------
(copy reservedconst)
(and %, %)
(and %, %)
(and %, reservedconst)
(and %, %)
(and %, reservedconst)
(or %, %)
(or %, %)
(or %, reservedconst)
(or %, %)
(or %, reservedconst)
(xor %, %)
(xor %, %)
(xor %, reservedconst)
(xor %, %)
(xor %, reservedconst)
(add %, %)
(add %, %)
(add %, reservedconst)
(add %, %)
(add %, reservedconst)
(sub %, %)
(sub %, %)
(sub %, %)
(sub %, %)
(sub reservedconst, %)
(sub reservedconst, %)
(mul %, %)
(mul %, %)
(mul %, reservedconst)
(mul %, %)
(mul %, reservedconst)
%
%
-----------------------------

----------------------------------------
define void @_Z8functionPhS_.1.2(* nocapture nowrite %0, * nocapture %1, i64 %_reservedc_0) nofree {
%2:
  br label %3

%3:
  %7 = phi i64 [ 0, %2 ], [ %33, %5 ]
  %8 = mul nsw nuw i64 %7, 1800
  %9 = mul nsw nuw i64 %7, 600
  br label %4

%4:
  %10 = phi i64 [ 0, %3 ], [ %31, %4 ]
  %11 = mul nsw nuw i64 %10, 3
  %12 = add nsw nuw i64 %8, %11
  %13 = gep * nocapture %1, 1 x i64 %12
  %14 = add nsw nuw i64 %10, %9
  %15 = mul nsw nuw i64 %14, 3
  %16 = gep inbounds * nocapture nowrite %0, 1 x i64 %15
  %17 = load i8, * %16, align 1
  %18 = zext i8 %17 to i16
  %19 = add nsw nuw i64 %15, 1
  %20 = gep inbounds * nocapture nowrite %0, 1 x i64 %19
  %21 = load i8, * %20, align 1
  %22 = zext i8 %21 to i16
  %23 = add nsw nuw i64 %15, 2
  %24 = gep inbounds * nocapture nowrite %0, 1 x i64 %23
  %25 = load i8, * %24, align 1
  %26 = zext i8 %25 to i16
  %27 = add nsw nuw i16 %22, %18
  %28 = add nsw nuw i16 %27, %26
  %29 = udiv i16 %28, 3
  %30 = trunc i16 %29 to i8
  memset * %13 align 1, i8 %30, i64 3
  %31 = add nsw nuw i64 %10, 1
  %32 = icmp eq i64 %31, 600
  br i1 %32, label %5, label %4

%5:
  %33 = add nsw nuw i64 %7, 1
  %34 = icmp eq i64 %33, 800
  br i1 %34, label %6, label %3#2

%3#2:
  %7#2 = phi i64 [ %33, %5 ]
  %8#2 = mul nsw nuw i64 %7#2, 1800
  %9#2 = mul nsw nuw i64 %7#2, 600
  br label %4#2

%4#2:
  %10#2 = phi i64 [ 0, %3#2 ], [ %31, %4 ]
  %11#2 = mul nsw nuw i64 %10#2, 3
  %12#2 = add nsw nuw i64 %8#2, %11#2
  %13#2 = gep * nocapture %1, 1 x i64 %12#2
  %14#2 = add nsw nuw i64 %10#2, %9#2
  %15#2 = mul nsw nuw i64 %14#2, 3
  %16#2 = gep inbounds * nocapture nowrite %0, 1 x i64 %15#2
  %17#2 = load i8, * %16#2, align 1
  %18#2 = zext i8 %17#2 to i16
  %19#2 = add nsw nuw i64 %15#2, 1
  %20#2 = gep inbounds * nocapture nowrite %0, 1 x i64 %19#2
  %21#2 = load i8, * %20#2, align 1
  %22#2 = zext i8 %21#2 to i16
  %23#2 = add nsw nuw i64 %15#2, 2
  %24#2 = gep inbounds * nocapture nowrite %0, 1 x i64 %23#2
  %25#2 = load i8, * %24#2, align 1
  %26#2 = zext i8 %25#2 to i16
  %27#2 = add nsw nuw i16 %22#2, %18#2
  %28#2 = add nsw nuw i16 %27#2, %26#2
  %29#2 = udiv i16 %28#2, 3
  %30#2 = trunc i16 %29#2 to i8
  memset * %13#2 align 1, i8 %30#2, i64 3
  %31#2 = add nsw nuw i64 %10#2, 1
  %32#2 = icmp eq i64 %31#2, 600
  br i1 %32#2, label %5#2, label %4#2

%5#2:
  %33#2 = add nsw nuw i64 %7#2, 1
  %34#2 = icmp eq i64 %33#2, 800
  br i1 %34#2, label %6, label %3#exit

%6:
  ret void

%3#exit:
  %7#exit = phi i64 [ %33#2, %5#2 ]
  %8#exit = mul nsw nuw i64 %7#exit, 1800
  %9#exit = mul nsw nuw i64 %7#exit, 600
  br label #sink
}
=>
define void @_Z8functionPhS_.1(* nocapture nowrite %0, * nocapture %1, i64 %_reservedc_0) nofree {
%2:
  br label %3

%3:
  %7 = phi i64 [ 0, %2 ], [ %32, %5 ]
  %8 = mul nsw nuw i64 %7, 1800
  br label %4

%4:
  %9 = phi i64 [ 0, %3 ], [ %30, %4 ]
  %10 = mul nsw nuw i64 %9, 3
  %11 = add nsw nuw i64 %8, %10
  %12 = gep * nocapture %1, 1 x i64 %11
  %13 = add nsw nuw i64 %9, %_reservedc_0
  %14 = mul nsw nuw i64 %13, 3
  %15 = gep inbounds * nocapture nowrite %0, 1 x i64 %14
  %16 = load i8, * %15, align 1
  %17 = zext i8 %16 to i16
  %18 = add nsw nuw i64 %14, 1
  %19 = gep inbounds * nocapture nowrite %0, 1 x i64 %18
  %20 = load i8, * %19, align 1
  %21 = zext i8 %20 to i16
  %22 = add nsw nuw i64 %14, 2
  %23 = gep inbounds * nocapture nowrite %0, 1 x i64 %22
  %24 = load i8, * %23, align 1
  %25 = zext i8 %24 to i16
  %26 = add nsw nuw i16 %21, %17
  %27 = add nsw nuw i16 %26, %25
  %28 = udiv i16 %27, 3
  %29 = trunc i16 %28 to i8
  memset * %12 align 1, i8 %29, i64 3
  %30 = add nsw nuw i64 %9, 1
  %31 = icmp eq i64 %30, 600
  br i1 %31, label %5, label %4

%5:
  %32 = add nsw nuw i64 %7, 1
  %33 = icmp eq i64 %32, 800
  br i1 %33, label %6, label %3#2

%3#2:
  %7#2 = phi i64 [ %32, %5 ]
  %8#2 = mul nsw nuw i64 %7#2, 1800
  br label %4#2

%4#2:
  %9#2 = phi i64 [ 0, %3#2 ], [ %30, %4 ]
  %10#2 = mul nsw nuw i64 %9#2, 3
  %11#2 = add nsw nuw i64 %8#2, %10#2
  %12#2 = gep * nocapture %1, 1 x i64 %11#2
  %13#2 = add nsw nuw i64 %9#2, %_reservedc_0
  %14#2 = mul nsw nuw i64 %13#2, 3
  %15#2 = gep inbounds * nocapture nowrite %0, 1 x i64 %14#2
  %16#2 = load i8, * %15#2, align 1
  %17#2 = zext i8 %16#2 to i16
  %18#2 = add nsw nuw i64 %14#2, 1
  %19#2 = gep inbounds * nocapture nowrite %0, 1 x i64 %18#2
  %20#2 = load i8, * %19#2, align 1
  %21#2 = zext i8 %20#2 to i16
  %22#2 = add nsw nuw i64 %14#2, 2
  %23#2 = gep inbounds * nocapture nowrite %0, 1 x i64 %22#2
  %24#2 = load i8, * %23#2, align 1
  %25#2 = zext i8 %24#2 to i16
  %26#2 = add nsw nuw i16 %21#2, %17#2
  %27#2 = add nsw nuw i16 %26#2, %25#2
  %28#2 = udiv i16 %27#2, 3
  %29#2 = trunc i16 %28#2 to i8
  memset * %12#2 align 1, i8 %29#2, i64 3
  %30#2 = add nsw nuw i64 %9#2, 1
  %31#2 = icmp eq i64 %30#2, 600
  br i1 %31#2, label %5#2, label %4#2

%5#2:
  %32#2 = add nsw nuw i64 %7#2, 1
  %33#2 = icmp eq i64 %32#2, 800
  br i1 %33#2, label %6, label %3#exit

%6:
  ret void

%3#exit:
  %7#exit = phi i64 [ %32#2, %5#2 ]
  %8#exit = mul nsw nuw i64 %7#exit, 1800
  br label #sink
}
constant synthesizer now only supports synthesizing integers and vector of integers
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/stefan/llvm/build/bin/opt -enable-new-pm=0 -load /home/stefan/minotaur/build/minotaur.so -so -S function.ll
1.	Running pass 'Function Pass Manager' on module 'function.ll'.
2.	Running pass 'Superoptimizer' on function '@_Z8functionPhS_'
 #0 0x00007fe373e7dc14 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0
 #1 0x00007fe373e7ac9e SignalHandler(int) Signals.cpp:0:0
 #2 0x00007fe3738b7210 (/lib/x86_64-linux-gnu/libc.so.6+0x46210)
 #3 0x00007fe373bb2f1d std::ostream::sentry::sentry(std::ostream&) (/lib/x86_64-linux-gnu/libstdc++.so.6+0x132f1d)
 #4 0x00007fe373bb36cc std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long) (/lib/x86_64-linux-gnu/libstdc++.so.6+0x1336cc)
 #5 0x00007fe3725a9e68 (anonymous namespace)::llvm2alive_::visitBinaryOperator(llvm::BinaryOperator&) llvm2alive.cpp:0:0
 #6 0x00007fe3725af6d8 llvm::InstVisitor<(anonymous namespace)::llvm2alive_, std::unique_ptr<IR::Instr, std::default_delete<IR::Instr> > >::visit(llvm::Instruction&) llvm2alive.cpp:0:0
 #7 0x00007fe3725b5180 (anonymous namespace)::llvm2alive_::run() llvm2alive.cpp:0:0
 #8 0x00007fe3725b644e llvm_util::llvm2alive(llvm::Function&, llvm::TargetLibraryInfo const&, std::vector<std::basic_string_view<char, std::char_traits<char> >, std::allocator<std::basic_string_view<char, std::char_traits<char> > > > const&) (/home/stefan/minotaur/build/minotaur.so+0x13a44e)
 #9 0x00007fe3724f5c7b minotaur::synthesize(llvm::Function&, llvm::TargetLibraryInfo*) (/home/stefan/minotaur/build/minotaur.so+0x79c7b)
#10 0x00007fe3741837d3 llvm::FPPassManager::runOnFunction(llvm::Function&) (/home/stefan/llvm/build/bin/../lib/libLLVMCore.so.14git+0x2727d3)
#11 0x00007fe374183a19 llvm::FPPassManager::runOnModule(llvm::Module&) (/home/stefan/llvm/build/bin/../lib/libLLVMCore.so.14git+0x272a19)
#12 0x00007fe374184c23 llvm::legacy::PassManagerImpl::run(llvm::Module&) (/home/stefan/llvm/build/bin/../lib/libLLVMCore.so.14git+0x273c23)
#13 0x000055ce202eefc4 main (/home/stefan/llvm/build/bin/opt+0x27fc4)
#14 0x00007fe3738980b3 __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:342:3
#15 0x000055ce202efe7e _start (/home/stefan/llvm/build/bin/opt+0x28e7e)
Segmentation fault (core dumped)
